{"version":3,"sources":["../../../../node_modules/framer-motion/src/components/AnimatePresence/utils.ts","../../../../node_modules/framer-motion/src/utils/use-composed-ref.ts","../../../../node_modules/framer-motion/src/components/AnimatePresence/PresenceChild.tsx","../../../../node_modules/framer-motion/src/components/AnimatePresence/index.tsx","../../../../node_modules/framer-motion/src/components/AnimatePresence/PopChild.tsx","../../../../src/lib/business-rules.ts"],"sourcesContent":["import { isValidElement, Children, ReactElement, ReactNode } from \"react\"\n\nexport type ComponentKey = string | number\n\nexport const getChildKey = (child: ReactElement<any>): ComponentKey =>\n    child.key || \"\"\n\nexport function onlyElements(children: ReactNode): ReactElement<any>[] {\n    const filtered: ReactElement<any>[] = []\n\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, (child) => {\n        if (isValidElement(child)) filtered.push(child)\n    })\n\n    return filtered\n}\n","/**\n * Taken from https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\nimport * as React from \"react\"\n\ntype PossibleRef<T> = React.Ref<T> | undefined\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T): void | (() => void) {\n    if (typeof ref === \"function\") {\n        return ref(value)\n    } else if (ref !== null && ref !== undefined) {\n        ;(ref as React.MutableRefObject<T>).current = value\n    }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n    return (node) => {\n        let hasCleanup = false\n        const cleanups = refs.map((ref) => {\n            const cleanup = setRef(ref, node)\n            if (!hasCleanup && typeof cleanup === \"function\") {\n                hasCleanup = true\n            }\n            return cleanup\n        })\n        // React <19 will log an error to the console if a callback ref returns a\n        // value. We don't use ref cleanups internally so this will only happen if a\n        // user's ref callback returns a value, which we only expect if they are\n        // using the cleanup functionality added in React 19.\n        if (hasCleanup) {\n            return () => {\n                for (let i = 0; i < cleanups.length; i++) {\n                    const cleanup = cleanups[i]\n                    if (typeof cleanup === \"function\") {\n                        cleanup()\n                    } else {\n                        setRef(refs[i], null)\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    return React.useCallback(composeRefs(...refs), refs)\n}\n\nexport { useComposedRefs }\n","\"use client\"\n\nimport * as React from \"react\"\nimport { useId, useMemo } from \"react\"\nimport {\n    PresenceContext,\n    type PresenceContextProps,\n} from \"../../context/PresenceContext\"\nimport { VariantLabels } from \"../../motion/types\"\nimport { useConstant } from \"../../utils/use-constant\"\nimport { PopChild } from \"./PopChild\"\n\ninterface PresenceChildProps {\n    children: React.ReactElement\n    isPresent: boolean\n    onExitComplete?: () => void\n    initial?: false | VariantLabels\n    custom?: any\n    presenceAffectsLayout: boolean\n    mode: \"sync\" | \"popLayout\" | \"wait\"\n    anchorX?: \"left\" | \"right\"\n    anchorY?: \"top\" | \"bottom\"\n    root?: HTMLElement | ShadowRoot\n}\n\nexport const PresenceChild = ({\n    children,\n    initial,\n    isPresent,\n    onExitComplete,\n    custom,\n    presenceAffectsLayout,\n    mode,\n    anchorX,\n    anchorY,\n    root\n}: PresenceChildProps) => {\n    const presenceChildren = useConstant(newChildrenMap)\n    const id = useId()\n\n    let isReusedContext = true\n    let context = useMemo((): PresenceContextProps => {\n        isReusedContext = false\n        return {\n            id,\n            initial,\n            isPresent,\n            custom,\n            onExitComplete: (childId: string) => {\n                presenceChildren.set(childId, true)\n\n                for (const isComplete of presenceChildren.values()) {\n                    if (!isComplete) return // can stop searching when any is incomplete\n                }\n\n                onExitComplete && onExitComplete()\n            },\n            register: (childId: string) => {\n                presenceChildren.set(childId, false)\n                return () => presenceChildren.delete(childId)\n            },\n        }\n    }, [isPresent, presenceChildren, onExitComplete])\n\n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    if (presenceAffectsLayout && isReusedContext) {\n        context = { ...context }\n    }\n\n    useMemo(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false))\n    }, [isPresent])\n\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete()\n    }, [isPresent])\n\n    children = (\n        <PopChild pop={mode === \"popLayout\"} isPresent={isPresent} anchorX={anchorX} anchorY={anchorY} root={root}>\n            {children}\n        </PopChild>\n    )\n\n    return (\n        <PresenceContext.Provider value={context}>\n            {children}\n        </PresenceContext.Provider>\n    )\n}\n\nfunction newChildrenMap(): Map<string, boolean> {\n    return new Map()\n}\n","\"use client\"\n\nimport * as React from \"react\"\nimport { useContext, useMemo, useRef, useState } from \"react\"\nimport { LayoutGroupContext } from \"../../context/LayoutGroupContext\"\nimport { useConstant } from \"../../utils/use-constant\"\nimport { useIsomorphicLayoutEffect } from \"../../utils/use-isomorphic-effect\"\nimport { PresenceChild } from \"./PresenceChild\"\nimport { AnimatePresenceProps } from \"./types\"\nimport { usePresence } from \"./use-presence\"\nimport { ComponentKey, getChildKey, onlyElements } from \"./utils\"\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nexport const AnimatePresence = ({\n    children,\n    custom,\n    initial = true,\n    onExitComplete,\n    presenceAffectsLayout = true,\n    mode = \"sync\",\n    propagate = false,\n    anchorX = \"left\",\n    anchorY = \"top\",\n    root\n}: React.PropsWithChildren<AnimatePresenceProps>) => {\n    const [isParentPresent, safeToRemove] = usePresence(propagate)\n\n    /**\n     * Filter any children that aren't ReactElements. We can only track components\n     * between renders with a props.key.\n     */\n    const presentChildren = useMemo(() => onlyElements(children), [children])\n\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */\n    const presentKeys =\n        propagate && !isParentPresent ? [] : presentChildren.map(getChildKey)\n\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */\n    const isInitialRender = useRef(true)\n\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */\n    const pendingPresentChildren = useRef(presentChildren)\n\n    /**\n     * Track which exiting children have finished animating out.\n     */\n    const exitComplete = useConstant(() => new Map<ComponentKey, boolean>())\n\n    /**\n     * Track which components are currently processing exit to prevent duplicate processing.\n     */\n    const exitingComponents = useRef(new Set<ComponentKey>())\n\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */\n    const [diffedChildren, setDiffedChildren] = useState(presentChildren)\n    const [renderedChildren, setRenderedChildren] = useState(presentChildren)\n\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false\n        pendingPresentChildren.current = presentChildren\n\n        /**\n         * Update complete status of exiting children.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const key = getChildKey(renderedChildren[i])\n\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false)\n                }\n            } else {\n                exitComplete.delete(key)\n                exitingComponents.current.delete(key)\n            }\n        }\n    }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")])\n\n    const exitingChildren: any[] = []\n\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [...presentChildren]\n\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const child = renderedChildren[i]\n            const key = getChildKey(child)\n\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child)\n                exitingChildren.push(child)\n            }\n        }\n\n        /**\n         * If we're in \"wait\" mode, and we have exiting children, we want to\n         * only render these until they've all exited.\n         */\n        if (mode === \"wait\" && exitingChildren.length) {\n            nextChildren = exitingChildren\n        }\n\n        setRenderedChildren(onlyElements(nextChildren))\n        setDiffedChildren(presentChildren)\n\n        /**\n         * Early return to ensure once we've set state with the latest diffed\n         * children, we can immediately re-render.\n         */\n        return null\n    }\n\n    if (\n        process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        renderedChildren.length > 1\n    ) {\n        console.warn(\n            `You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`\n        )\n    }\n\n    /**\n     * If we've been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */\n    const { forceRender } = useContext(LayoutGroupContext)\n\n    return (\n        <>\n            {renderedChildren.map((child) => {\n                const key = getChildKey(child)\n\n                const isPresent =\n                    propagate && !isParentPresent\n                        ? false\n                        : presentChildren === renderedChildren ||\n                          presentKeys.includes(key)\n\n                const onExit = () => {\n                    if (exitingComponents.current.has(key)) {\n                        return\n                    }\n                    exitingComponents.current.add(key)\n\n                    if (exitComplete.has(key)) {\n                        exitComplete.set(key, true)\n                    } else {\n                        return\n                    }\n\n                    let isEveryExitComplete = true\n                    exitComplete.forEach((isExitComplete) => {\n                        if (!isExitComplete) isEveryExitComplete = false\n                    })\n\n                    if (isEveryExitComplete) {\n                        forceRender?.()\n                        setRenderedChildren(pendingPresentChildren.current)\n\n                        propagate && safeToRemove?.()\n\n                        onExitComplete && onExitComplete()\n                    }\n                }\n\n                return (\n                    <PresenceChild\n                        key={key}\n                        isPresent={isPresent}\n                        initial={\n                            !isInitialRender.current || initial\n                                ? undefined\n                                : false\n                        }\n                        custom={custom}\n                        presenceAffectsLayout={presenceAffectsLayout}\n                        mode={mode}\n                        root={root}\n                        onExitComplete={isPresent ? undefined : onExit}\n                        anchorX={anchorX}\n                        anchorY={anchorY}\n                    >\n                        {child}\n                    </PresenceChild>\n                )\n            })}\n        </>\n    )\n}\n","\"use client\"\n\nimport { isHTMLElement } from \"motion-dom\"\nimport * as React from \"react\"\nimport { useContext, useId, useInsertionEffect, useRef } from \"react\"\n\nimport { MotionConfigContext } from \"../../context/MotionConfigContext\"\nimport { useComposedRefs } from \"../../utils/use-composed-ref\"\n\ninterface Size {\n    width: number\n    height: number\n    top: number\n    left: number\n    right: number\n    bottom: number\n}\n\ninterface Props {\n    children: React.ReactElement\n    isPresent: boolean\n    anchorX?: \"left\" | \"right\"\n    anchorY?: \"top\" | \"bottom\"\n    root?: HTMLElement | ShadowRoot\n    pop?: boolean\n}\n\ninterface MeasureProps extends Props {\n    childRef: React.RefObject<HTMLElement | null>\n    sizeRef: React.RefObject<Size>\n}\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component<MeasureProps> {\n    getSnapshotBeforeUpdate(prevProps: MeasureProps) {\n        const element = this.props.childRef.current\n        if (element && prevProps.isPresent && !this.props.isPresent && this.props.pop !== false) {\n            const parent = element.offsetParent\n            const parentWidth = isHTMLElement(parent)\n                ? parent.offsetWidth || 0\n                : 0\n            const parentHeight = isHTMLElement(parent)\n                ? parent.offsetHeight || 0\n                : 0\n\n            const size = this.props.sizeRef.current!\n            size.height = element.offsetHeight || 0\n            size.width = element.offsetWidth || 0\n            size.top = element.offsetTop\n            size.left = element.offsetLeft\n            size.right = parentWidth - size.width - size.left\n            size.bottom = parentHeight - size.height - size.top\n        }\n\n        return null\n    }\n\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() {}\n\n    render() {\n        return this.props.children\n    }\n}\n\nexport function PopChild({ children, isPresent, anchorX, anchorY, root, pop }: Props) {\n    const id = useId()\n    const ref = useRef<HTMLElement>(null)\n    const size = useRef<Size>({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n    })\n    const { nonce } = useContext(MotionConfigContext)\n    /**\n     * In React 19, refs are passed via props.ref instead of element.ref.\n     * We check props.ref first (React 19) and fall back to element.ref (React 18).\n     */\n    const childRef =\n        (children.props as { ref?: React.Ref<HTMLElement> })?.ref ??\n        (children as unknown as { ref?: React.Ref<HTMLElement> })?.ref\n    const composedRef = useComposedRefs(ref, childRef)\n\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    useInsertionEffect(() => {\n        const { width, height, top, left, right, bottom } = size.current\n        if (isPresent || pop === false || !ref.current || !width || !height) return\n\n        const x = anchorX === \"left\" ? `left: ${left}` : `right: ${right}`\n        const y = anchorY === \"bottom\" ? `bottom: ${bottom}` : `top: ${top}`\n\n        ref.current.dataset.motionPopId = id\n\n        const style = document.createElement(\"style\")\n        if (nonce) style.nonce = nonce\n\n        const parent = root ?? document.head\n        parent.appendChild(style)\n\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            ${y}px !important;\n          }\n        `)\n        }\n\n        return () => {\n            if (parent.contains(style)) {\n                parent.removeChild(style)\n            }\n        }\n    }, [isPresent])\n\n    return (\n        <PopChildMeasure isPresent={isPresent} childRef={ref} sizeRef={size} pop={pop}>\n            {pop === false\n                ? children\n                : React.cloneElement(children as any, { ref: composedRef })}\n        </PopChildMeasure>\n    )\n}\n","// ============================================================================\n// Regras de Negocio — Flow CRM\n// Funcoes puras sem dependencias de React ou stores.\n// ============================================================================\n\nimport type {\n  Activity,\n  ActivityStatus,\n  Client,\n  ClientStage,\n  HealthScore,\n  Opportunity,\n  PipelineStage,\n  Temperature,\n} from \"@/types\";\n\n// ─── Constantes ─────────────────────────────────────────────────────────────\n\n/** Percentual padrao de comissao */\nconst DEFAULT_COMMISSION_PERCENTAGE = 5;\n\n/** Ordem dos estagios do pipeline de vendas */\nexport const PIPELINE_STAGE_ORDER: PipelineStage[] = [\n  \"lead-in\",\n  \"contato-feito\",\n  \"reuniao-agendada\",\n  \"proposta-enviada\",\n  \"negociacao\",\n  \"fechamento\",\n];\n\n/** Ordem dos estagios do cliente */\nconst CLIENT_STAGE_ORDER: ClientStage[] = [\n  \"onboarding\",\n  \"implantacao\",\n  \"acompanhamento\",\n  \"retencao\",\n  \"churn\",\n];\n\n/** Cargos oficiais com score de patente fixo e imutável (0-100). */\nexport const RESTAURANT_POSITIONS = [\n  { label: \"Proprietário\", value: \"proprietario\", patentScore: 100 },\n  { label: \"Sócio\", value: \"socio\", patentScore: 90 },\n  { label: \"Diretor\", value: \"diretor\", patentScore: 80 },\n  { label: \"Gerente Geral\", value: \"gerente-geral\", patentScore: 70 },\n  { label: \"Gerente\", value: \"gerente\", patentScore: 60 },\n  { label: \"Financeiro\", value: \"financeiro\", patentScore: 50 },\n  { label: \"Operacional\", value: \"operacional\", patentScore: 40 },\n  {\n    label: \"Supervisor/Líder de Turno\",\n    value: \"supervisor-lider-turno\",\n    patentScore: 30,\n  },\n  {\n    label: \"Caixa/Recepcionista\",\n    value: \"caixa-recepcionista\",\n    patentScore: 20,\n  },\n  { label: \"Garçom/Atendente\", value: \"garcom-atendente\", patentScore: 10 },\n] as const;\n\nexport type RestaurantPosition = (typeof RESTAURANT_POSITIONS)[number][\"value\"];\n\ntype PatentContactLike = {\n  cargo?: string | null;\n};\n\n/**\n * Score individual de patente por cargo.\n * Valores ausentes ou desconhecidos retornam 0.\n */\nexport function getPositionPatentScore(position: string | null | undefined): number {\n  if (!position) return 0;\n  return RESTAURANT_POSITIONS.find((item) => item.value === position)?.patentScore ?? 0;\n}\n\n/**\n * Score de Patente do card: maior score individual entre os contatos.\n * Regra: MAX sem soma/média/ponderação.\n */\nexport function calculateCardPatentScore<T extends PatentContactLike>(contacts: T[]): number {\n  if (contacts.length === 0) return 0;\n  return Math.max(...contacts.map((contact) => getPositionPatentScore(contact.cargo)));\n}\n\nfunction parseISODateLocal(dateStr: string): Date {\n  const [yearRaw, monthRaw, dayRaw] = dateStr.split(\"-\").map(Number);\n  const year = Number.isFinite(yearRaw) ? yearRaw : 1970;\n  const month = Number.isFinite(monthRaw) ? monthRaw - 1 : 0;\n  const day = Number.isFinite(dayRaw) ? dayRaw : 1;\n  return new Date(year, month, day);\n}\n\nfunction startOfDayLocal(date: Date): Date {\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate());\n}\n\nexport function getActivityDueAt(\n  activity: Pick<Activity, \"dueDate\" | \"dueTime\">\n): Date {\n  const dueDate = parseISODateLocal(activity.dueDate);\n\n  if (activity.dueTime) {\n    const [hoursRaw, minutesRaw] = activity.dueTime.split(\":\").map(Number);\n    const hours = Number.isFinite(hoursRaw) ? hoursRaw : 23;\n    const minutes = Number.isFinite(minutesRaw) ? minutesRaw : 59;\n    dueDate.setHours(hours, minutes, 0, 0);\n    return dueDate;\n  }\n\n  dueDate.setHours(23, 59, 59, 999);\n  return dueDate;\n}\n\nexport function isActivityOverdueAt(\n  activity: Activity,\n  now: Date = new Date()\n): boolean {\n  if (activity.status === \"completed\" || activity.status === \"cancelled\") {\n    return false;\n  }\n\n  if (activity.status === \"overdue\") {\n    return true;\n  }\n\n  if (activity.status !== \"pending\") {\n    return false;\n  }\n\n  return getActivityDueAt(activity).getTime() < now.getTime();\n}\n\nexport function isActivitySlaRiskAt(\n  activity: Activity,\n  now: Date = new Date()\n): boolean {\n  if (activity.status !== \"pending\" || isActivityOverdueAt(activity, now)) {\n    return false;\n  }\n\n  const today = startOfDayLocal(now);\n  const tomorrow = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 1);\n  const due = startOfDayLocal(parseISODateLocal(activity.dueDate));\n\n  return due.getTime() >= today.getTime() && due.getTime() <= tomorrow.getTime();\n}\n\n// ─── 1. Status Efetivo de Atividade ────────────────────────────────────────\n\n/**\n * Retorna o status efetivo de uma atividade.\n * Se a atividade esta \"pending\" e o dueDate ja passou, retorna \"overdue\".\n */\nexport function getEffectiveActivityStatus(\n  activity: Activity,\n  now: Date = new Date()\n): ActivityStatus {\n  if (activity.status === \"completed\" || activity.status === \"cancelled\") {\n    return activity.status;\n  }\n\n  if (activity.status === \"pending\" && isActivityOverdueAt(activity, now)) {\n    return \"overdue\";\n  }\n\n  return activity.status;\n}\n\n// ─── 2. Calculo de Temperatura ─────────────────────────────────────────────\n\n/**\n * Calcula a temperatura automatica de uma oportunidade.\n *\n * Fatores:\n * - Dias desde ultima atualizacao: <3d = 3pts, 3-7d = 2pts, >7d = 1pt\n * - Bonus por valor acima da media (+1pt)\n * - Bonus por estagio avancado (negociacao/fechamento) (+1pt)\n *\n * Score >= 4 = hot, >= 2 = warm, else cold\n */\nexport function calculateTemperature(\n  opportunity: Pick<Opportunity, \"updatedAt\" | \"value\" | \"stage\">,\n  averageDealValue: number = 10000,\n  now: Date = new Date()\n): Temperature {\n  const updatedAt = new Date(opportunity.updatedAt);\n  const daysSinceUpdate = Math.floor(\n    (now.getTime() - updatedAt.getTime()) / (1000 * 60 * 60 * 24)\n  );\n\n  // Base: dias desde ultima atualizacao\n  let score = 0;\n  if (daysSinceUpdate < 3) {\n    score = 3; // hot\n  } else if (daysSinceUpdate <= 7) {\n    score = 2; // warm\n  } else {\n    score = 1; // cold\n  }\n\n  // Bonus: valor acima da media\n  if (opportunity.value > averageDealValue * 1.5) {\n    score += 1;\n  }\n\n  // Bonus: estagios avancados (negociacao ou fechamento)\n  const stageIndex = PIPELINE_STAGE_ORDER.indexOf(opportunity.stage);\n  if (stageIndex >= 4) {\n    score += 1;\n  }\n\n  // Mapear score para temperatura\n  if (score >= 4) return \"hot\";\n  if (score >= 2) return \"warm\";\n  return \"cold\";\n}\n\n// ─── 3. Calculo de Health Score ────────────────────────────────────────────\n\n/**\n * Calcula o Health Score numerico de um cliente (0-100).\n *\n * Componentes:\n * - Dias desde ultima interacao (0-40 pontos)\n * - Receita mensal relativa a media (0-20 pontos)\n * - Proximidade do vencimento do contrato (0-20 pontos)\n * - Progressao de estagio (0-20 pontos)\n */\nexport function calculateHealthScore(\n  client: Pick<Client, \"lastInteraction\" | \"monthlyRevenue\" | \"contractEnd\" | \"stage\">,\n  averageMonthlyRevenue: number = 10000,\n  now: Date = new Date()\n): { numericScore: number; category: HealthScore } {\n  let total = 0;\n\n  // 1. Dias desde ultima interacao (0-40 pontos)\n  if (client.lastInteraction) {\n    const lastInteraction = new Date(client.lastInteraction);\n    const daysSince = Math.floor(\n      (now.getTime() - lastInteraction.getTime()) / (1000 * 60 * 60 * 24)\n    );\n    // 0 dias = 40pts, 30+ dias = 0pts, linear\n    total += Math.max(0, Math.round(40 * (1 - daysSince / 30)));\n  }\n  // Sem interacao registrada = 0 pontos\n\n  // 2. Receita mensal relativa (0-20 pontos)\n  if (averageMonthlyRevenue > 0) {\n    const revenueRatio = client.monthlyRevenue / averageMonthlyRevenue;\n    // ratio >= 1.0 = 20pts, ratio 0 = 0pts, capped at 20\n    total += Math.min(20, Math.round(20 * revenueRatio));\n  }\n\n  // 3. Proximidade do vencimento do contrato (0-20 pontos)\n  if (client.contractEnd) {\n    const contractEnd = new Date(client.contractEnd);\n    const daysUntilEnd = Math.floor(\n      (contractEnd.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)\n    );\n    if (daysUntilEnd <= 0) {\n      total += 0; // Contrato expirado\n    } else if (daysUntilEnd <= 30) {\n      total += 5; // Proximo de expirar\n    } else if (daysUntilEnd <= 90) {\n      total += 10;\n    } else if (daysUntilEnd <= 180) {\n      total += 15;\n    } else {\n      total += 20; // Contrato seguro\n    }\n  } else {\n    total += 15; // Sem data de fim = contrato aberto / indefinido\n  }\n\n  // 4. Progressao de estagio (0-20 pontos)\n  const stageIndex = CLIENT_STAGE_ORDER.indexOf(client.stage);\n  if (client.stage === \"churn\") {\n    total += 0;\n  } else {\n    // onboarding=5, implantacao=10, acompanhamento=15, retencao=20\n    total += (stageIndex + 1) * 5;\n  }\n\n  // Classificar\n  const category: HealthScore =\n    total >= 70 ? \"good\" : total >= 40 ? \"warning\" : \"critical\";\n\n  return { numericScore: Math.min(100, total), category };\n}\n\n// ─── 4. Calculo de Lead Score ──────────────────────────────────────────────\n\n/**\n * Calcula o Lead Score de uma oportunidade (0-100).\n *\n * Componentes:\n * - Numero de atividades relacionadas (0-25 pontos)\n * - Temperatura (hot=25, warm=15, cold=5)\n * - Valor do deal relativo a media (0-20 pontos)\n * - Progressao de estagio (0-15 pontos)\n * - Dias no pipeline / frescura (0-15 pontos, decrescente)\n */\nexport function calculateLeadScore(\n  opportunity: Pick<Opportunity, \"value\" | \"temperature\" | \"stage\" | \"createdAt\">,\n  relatedActivities: Activity[],\n  averageDealValue: number = 10000,\n  now: Date = new Date()\n): number {\n  let total = 0;\n\n  // 1. Atividades (0-25 pontos) - 5pts por atividade, max 25\n  const activityCount = relatedActivities.length;\n  total += Math.min(25, activityCount * 5);\n\n  // 2. Temperatura (0-25 pontos)\n  switch (opportunity.temperature) {\n    case \"hot\":\n      total += 25;\n      break;\n    case \"warm\":\n      total += 15;\n      break;\n    case \"cold\":\n      total += 5;\n      break;\n  }\n\n  // 3. Valor relativo (0-20 pontos)\n  if (averageDealValue > 0) {\n    const valueRatio = opportunity.value / averageDealValue;\n    total += Math.min(20, Math.round((20 * Math.min(valueRatio, 2)) / 2));\n  }\n\n  // 4. Progressao de estagio (0-15 pontos)\n  const stageIndex = PIPELINE_STAGE_ORDER.indexOf(opportunity.stage);\n  // lead-in=0, contato-feito=3, reuniao-agendada=6, proposta-enviada=9, negociacao=12, fechamento=15\n  total += stageIndex * 3;\n\n  // 5. Dias no pipeline (0-15 pontos, decrescente — leads frescos valem mais)\n  const createdAt = new Date(opportunity.createdAt);\n  const daysInPipeline = Math.floor(\n    (now.getTime() - createdAt.getTime()) / (1000 * 60 * 60 * 24)\n  );\n  total += Math.max(0, Math.round(15 * (1 - daysInPipeline / 60)));\n\n  return Math.min(100, Math.max(0, total));\n}\n\n// ─── 5. Comissao Projetada ─────────────────────────────────────────────────\n\n/**\n * Calcula a comissao projetada para um contrato ganho.\n */\nexport function calculateProjectedCommission(\n  contractValue: number,\n  commissionPercentage: number = DEFAULT_COMMISSION_PERCENTAGE\n): { commissionValue: number; percentage: number } {\n  const commissionValue = contractValue * (commissionPercentage / 100);\n  return {\n    commissionValue: Math.round(commissionValue * 100) / 100,\n    percentage: commissionPercentage,\n  };\n}\n\n// ─── 6. SLA Deadline ───────────────────────────────────────────────────────\n\n/**\n * Calcula a nova deadline de SLA ao mover para um novo estagio.\n */\nexport function calculateSlaDeadline(\n  slaHours: number,\n  now: Date = new Date()\n): string {\n  const deadline = new Date(now.getTime() + slaHours * 60 * 60 * 1000);\n  return deadline.toISOString();\n}\n\n// ─── 7. Formatacao de Moeda ────────────────────────────────────────────────\n\n/**\n * Formata valor monetario em Real Brasileiro.\n */\nexport function formatCurrencyBRL(value: number): string {\n  return new Intl.NumberFormat(\"pt-BR\", {\n    style: \"currency\",\n    currency: \"BRL\",\n    minimumFractionDigits: 0,\n  }).format(value);\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4]}